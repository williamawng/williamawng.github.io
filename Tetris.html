<!--This game is generated by ChatGPT-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simplified Tetris</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #333;
            font-family: Arial, sans-serif;
            color: #fff;
        }

        canvas {
            border: 2px solid #fff;
        }
    </style>
</head>
<body>
    <canvas id="tetrisCanvas" width="240" height="400"></canvas>

    <script>
        const canvas = document.getElementById('tetrisCanvas');
        const ctx = canvas.getContext('2d');

        const ROWS = 20;
        const COLS = 10;
        const BLOCK_SIZE = 20;
        const EMPTY_BLOCK = 'rgba(0, 0, 0, 0)';
        const colors = [
            EMPTY_BLOCK,
            'cyan', 'blue', 'orange', 'yellow', 'green', 'purple', 'red'
        ];

        let board = [];
        let currentPiece;
        let intervalId;

        // Initialize the game
        function init() {
            board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            currentPiece = createPiece();
            intervalId = setInterval(updateGame, 500);
            drawBoard();
        }

        // Draw the game board
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            board.forEach((row, i) => {
                row.forEach((col, j) => {
                    drawBlock(j, i, colors[col]);
                });
            });
        }

        // Draw a single block
        function drawBlock(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = '#fff';
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }

        // Create a new piece
        function createPiece() {
            const pieces = [
                [[1, 1, 1, 1]],
                [[1, 1, 1], [0, 1, 0]],
                [[1, 1, 1], [1, 0, 0]],
                [[1, 1], [1, 1]],
                [[0, 1, 1], [1, 1, 0]],
                [[1, 1, 0], [0, 1, 1]],
                [[1, 1, 1], [0, 0, 1]],
            ];
            const piece = pieces[Math.floor(Math.random() * pieces.length)];
            const color = Math.floor(Math.random() * (colors.length - 1)) + 1;
            return { piece, color, x: 3, y: 0 };
        }

        // Draw the current piece
        function drawPiece() {
            currentPiece.piece.forEach((row, i) => {
                row.forEach((col, j) => {
                    if (col) {
                        drawBlock(currentPiece.x + j, currentPiece.y + i, colors[currentPiece.color]);
                    }
                });
            });
        }

        // Check if piece can move
        function canMove(dx, dy) {
            return currentPiece.piece.every((row, i) => {
                return row.every((col, j) => {
                    if (!col) return true;
                    const newX = currentPiece.x + j + dx;
                    const newY = currentPiece.y + i + dy;
                    return newX >= 0 && newX < COLS && newY < ROWS && (newY < 0 || board[newY][newX] === 0);
                });
            });
        }

        // Move piece left or right
        function movePiece(dx) {
            if (canMove(dx, 0)) {
                currentPiece.x += dx;
                drawBoard();
                drawPiece();
            }
        }

        // Rotate piece
        function rotatePiece() {
            const rotatedPiece = currentPiece.piece[0].map((col, i) => {
                return currentPiece.piece.map(row => row[i]).reverse();
            });
            if (canMove(0, 0, rotatedPiece)) {
                currentPiece.piece = rotatedPiece;
                drawBoard();
                drawPiece();
            }
        }

        // Update game loop
        function updateGame() {
            if (canMove(0, 1)) {
                currentPiece.y++;
            } else {
                currentPiece.piece.forEach((row, i) => {
                    row.forEach((col, j) => {
                        if (col) {
                            board[currentPiece.y + i][currentPiece.x + j] = currentPiece.color;
                        }
                    });
                });
                checkLines();
                currentPiece = createPiece();
                if (!canMove(0, 1)) {
                    clearInterval(intervalId);
                    alert('Game Over!');
                }
            }
            drawBoard();
            drawPiece();
        }

        // Check for completed lines
        function checkLines() {
            let linesCleared = 0;
            for (let i = ROWS - 1; i >= 0; i--) {
                if (board[i].every(col => col !== 0)) {
                    board.splice(i, 1);
                    board.unshift(Array(COLS).fill(0));
                    linesCleared++;
                }
            }
            if (linesCleared > 0) {
                console.log(`Lines cleared: ${linesCleared}`);
            }
        }

        // Keyboard controls
        document.addEventListener('keydown', e => {
            switch (e.key) {
                case 'ArrowLeft':
                    movePiece(-1);
                    break;
                case 'ArrowRight':
                    movePiece(1);
                    break;
                case 'ArrowDown':
                    updateGame();
                    break;
                case 'ArrowUp':
                    rotatePiece();
                    break;
            }
        });

        // Start the game
        init();
    </script>
</body>
</html>
